#!/usr/bin/env python3

import json
import logging
import os
import re

import spotipy
import spotipy.util as util
from typing import List

# TODO: git history


class Track(object):
    def __init__(self, artist: str, album: str, title: str, url: str) -> None:
        self.artist = artist
        self.album = album
        self.title = title
        self.url = url

    def __str__(self) -> str:
        return f"{self.artist} | {self.title}"


class Playlist(object):
    def __init__(self, name: str, tracks: List[Track]) -> None:
        self.name = name
        self.tracks = tracks

    def dict(self):
        return dict(
            name=self.name,
            tracks=[t.__dict__ for t in self.tracks]
        )

    def markdown(self) -> str:
        s = f"{self.name}\n"
        s += '-' * len(self.name) + "\n\n* " + \
             '\n* '.join([str(t) for t in self.tracks])
        return s


def create_tracklist(tracks: dict) -> List[Track]:
    t = []
    for i, item in enumerate(tracks['items']):
        track = Track(
            artist=', '.join([a["name"] for a in item['track']['artists']]).strip(),
            album=item['track']['album']['name'].strip(),
            title=item['track']['name'].strip(),
            url=item['track']['external_urls'].get("spotify", "").strip()
        )
        t.append(track)
    return t


def create_playlist(spot: spotipy.Spotify, user: str, playlist: dict) -> Playlist:
    results = spot.user_playlist(user, playlist['id'], fields="tracks,next")
    tracks_result = results['tracks']
    tracks = create_tracklist(tracks_result)
    while tracks_result['next']:
        tracks_result = spot.next(tracks_result)
        tracks += create_tracklist(tracks_result)

    return Playlist(name=playlist['name'], tracks=tracks)


def get_all_playlists(spot: spotipy.Spotify, user: str, exclude_regex: str) -> List[Playlist]:
    all_playlists = []  # type: List[dict]
    playlist_result = spot.user_playlists(user)
    while playlist_result['next']:
        all_playlists += playlist_result['items']
        playlist_result = spot.next(playlist_result)

    logging.info("fetching playlist contents...")
    # get all self-owned playlists that do not match regex, then sort by name
    rex = re.compile(exclude_regex)
    playlists = sorted(
        filter(lambda p: p['owner']['id'] == user and not re.match(rex, p['name']), all_playlists),
        key=lambda p: p["name"].lower()
    )

    result = []
    total = len(playlists)
    for i, playlist in enumerate(playlists):
        logging.info(f"{i+1}/{total} ({playlist['name']})")
        result.append(create_playlist(spot, user, playlist))
    return result


if __name__ == '__main__':
    logging.basicConfig(format='%(asctime)s [%(levelname)s] %(message)s', level=logging.INFO)
    EXCLUDE_REGEX = os.environ["SPOT_EXCLUDE"]

    USER = os.environ["SPOT_USER"]
    TOKEN = util.prompt_for_user_token(
        username=USER,
        scope='user-library-read',
        client_id=os.environ["SPOT_CLIENT_ID"],
        client_secret=os.environ["SPOT_CLIENT_SECRET"],
        redirect_uri="http://localhost/"
    )
    SPOT = spotipy.Spotify(auth=TOKEN)

    logging.info("fetching playlists...")
    playlists = get_all_playlists(SPOT, USER, EXCLUDE_REGEX)

    logging.info("writing markdown...")
    with open(os.path.expanduser("~/spot/spot.md"), 'w') as f:
        for p in playlists:
            f.write(p.markdown())
            f.write("\n\n")

    logging.info("writing json...")
    with open(os.path.expanduser("~/spot/spot.json"), 'w') as f:
        f.write(json.dumps([p.dict() for p in playlists], indent=2))
