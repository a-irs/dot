#!/usr/bin/env python3

import sys
from pathlib import Path
import subprocess
import typing

# TODO:
# delete files that have no source any more

DIR_IN = Path(sys.argv[1])
DIR_OUT = Path(sys.argv[2])
TYPES = {
    "photo": [".jpg", ".jpeg", ".psd", ".tif", ".tiff"],
    "video": [".mp4", ".avi"]
}


def run(command: str) -> subprocess.CompletedProcess:
    return subprocess.run(command, check=True, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)


def get_dest(input_file: Path, input_base_dir: Path, output_base_dir: Path, extension: str) -> Path:
    # e.g. when called with extension=mp4 and input_file=...avi, write output as .avi.mp4
    original_extension = input_file.suffix.lower()
    if original_extension != extension.lower():
        extension = original_extension.lower() + extension

    # recreate directory structure
    structure = Path(str(input_file).replace(str(input_base_dir) + "/", "", 1)).parent
    output_dir = output_base_dir / structure

    output_file = output_dir / Path(input_file.name).with_suffix(extension)
    return output_file


def convert_photo(src_file: Path, dest_file: Path, size: int, quality: int) -> typing.Optional[Path]:
    dest_file.parent.mkdir(parents=True, exist_ok=True)

    command = f'convert "{src_file}" -flatten -auto-orient -quality {quality} -resize {size}x{size}\\> "{dest_file}"'
    command2 = f'exiftool -overwrite_original -all= -ifd1:all= -previewimage= -thumbnailimage= "{dest_file}"'
    run(command)
    run(command2)

    return dest_file


def convert_video(src_file: Path, dest_file: Path, size: int, quality: int) -> typing.Optional[Path]:
    dest_file.parent.mkdir(parents=True, exist_ok=True)

    # -y overwrite, -nostdin to not cause weird issues https://www.igorkromin.net/index.php/2016/12/23/prevent-errors-during-ffmpeg-execution-in-a-loop/
    command = f"""
      ffmpeg -nostdin -y
        -i "{src_file}"
        -c:v libx264 -preset medium -crf "{quality}" -tune film
        -filter:v scale="{size}":-1
        -profile:v high -level 4.0
        -pix_fmt yuv420p
        -c:a aac -b:a 128k
        -movflags +write_colr
        "{dest_file}"
    """
    exec = ' '.join([l.strip() for l in command.splitlines() if l])
    run(exec)

    return dest_file


def find(dir: Path, extensions: typing.List[str]) -> typing.List[Path]:
    files: typing.List[Path] = []
    for f in sorted(Path(dir).glob('2019/*/*/*'), reverse=True):
        if any([f.suffix.lower().endswith(ext) for ext in extensions]):
            files.append(f)
    return files


def main() -> None:
    photo_files_todo = []
    for f in find(DIR_IN, TYPES["photo"]):
        for (size, quality) in [(1280, 60), (2560, 70)]:
            dest_file = get_dest(f, DIR_IN, DIR_OUT / str(size), ".jpg")
            if not (dest_file.is_file() and dest_file.stat().st_size > 0):
                photo_files_todo.append((f, dest_file, size, quality))

    photo_files_todo_len = len(photo_files_todo)
    for (i, (src_file, dest_file, size, quality)) in enumerate(photo_files_todo):
        print("{}/{} ({}%) - {} - {}".format(i + 1, photo_files_todo_len, round((i + 1) / photo_files_todo_len * 100, 1), size, src_file))
        convert_photo(src_file=src_file, dest_file=dest_file, size=size, quality=quality)

    video_files_todo = []
    for f in find(DIR_IN, TYPES["video"]):
        dest_file = get_dest(f, DIR_IN, DIR_OUT / "1280", ".mp4")
        if not (dest_file.is_file() and dest_file.stat().st_size > 0):
            video_files_todo.append((f, dest_file, 854, 25))

        dest_file = get_dest(f, DIR_IN, DIR_OUT / "2560", ".mp4")
        if not (dest_file.is_file() and dest_file.stat().st_size > 0):
            video_files_todo.append((f, dest_file, 1280, 25))

    video_files_todo_len = len(video_files_todo)
    for (i, (src_file, dest_file, size, quality)) in enumerate(video_files_todo):
        print("{}/{} ({}%) - {} - {}".format(i + 1, video_files_todo_len, round((i + 1) / video_files_todo_len * 100, 1), size, src_file))
        convert_video(src_file=src_file, dest_file=dest_file, size=size, quality=quality)


if __name__ == "__main__":
    main()
